<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Introdução ao geoprocessamento para Etnobiologia e Conservação da Biodiversidade</title>
    <meta charset="utf-8" />
    <meta name="author" content="Maurício H. Vancine" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <script src="https://use.fontawesome.com/5235085b15.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introdução ao geoprocessamento para Etnobiologia e Conservação da Biodiversidade <br><br>
## 3 Estrutura de dados <br><br> xaringan [presentation ninja]
### Maurício H. Vancine
### 30/09/2019

---




class: clear, center, middle
background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 700px
background-position: 50% 50%

---

# 3 Estrutura e manejo de dados
## Tópicos
3.1 Atributos dos objetos
&lt;br&gt;
3.2 Modos dos objetos
&lt;br&gt;
3.3 Modos dos objetos: numérico (**numeric**)
&lt;br&gt;
3.4 Modos dos objetos: caracter (**character**)
&lt;br&gt;
3.5 Modos dos objetos: lógico (**logical**)
&lt;br&gt;
3.6 Estrutura dos objetos
&lt;br&gt;
3.7 Estrutura dos objetos: vetor (**vector**)
&lt;br&gt;
3.8 Estrutura dos objetos: fator (**factor**)
&lt;br&gt;
3.9 Estrutura dos objetos: matriz (**matrix**)
&lt;br&gt; 
3.10 Estrutura dos objetos: data frame (**data frame**)
&lt;br&gt; 
3.11 Estrutura dos objetos: lista (**list**)

---

# 3.1 Atributos dos objetos

## Atribuição

&lt;br&gt;&lt;br&gt;

## **palavra &lt;- dados**

--

&lt;br&gt;&lt;br&gt;


```r
## atribuicao - simbolo (&lt;-)
obj.10 &lt;- 10 
obj.10
```

```
## [1] 10
```

---

# 3.1 Atributos dos objetos

## Atributos dos objetos no R

### Objetos possuem **três características**:

&lt;br&gt;

--

### 1. **Nome**: palavra que o R reconhece os dados atribuídos

--

### 2. **Conteúdo**: dados em si

--

### 3. **Atributos**: modos (*natureza*) e estruturas (*organização*)

---

# 3.2 Modos dos objetos

## Modos (*natureza*): numeric, character e logical

--

### **Natureza** dos **elementos** que compõem os objetos

---

# 3.3 Modos dos objetos: numeric

## **Numeric**: números inteiros ou decimais

```r
# numeric
obj.num &lt;- 1
obj.num
```

```
## [1] 1
```
--

```r
# mode
mode(obj.num)
```

```
## [1] "numeric"
```

---

# 3.4 Modos dos objetos: character

### 2. **character**: texto

--

```r
# character
obj.cha &lt;- "a" # atencao para as aspas
obj.cha
```

```
## [1] "a"
```
--

```r
# mode
mode(obj.cha)
```

```
## [1] "character"
```

---

# 3.5 Modos dos objetos: logical

### 3. **logical**: assume apenas dois valores (booleano)

--


```r
# logical
obj.log &lt;- TRUE # maiusculas e sem aspas
obj.log
```

```
## [1] TRUE
```
--

```r
# mode
mode(obj.log)
```

```
## [1] "logical"
```

---

# 3.5 Modos dos objetos: resumindo

## Resumindo:

### A **natureza** dos **elementos** irá definir os **modos** dos objetos

--

&lt;br&gt;&lt;br&gt;

## Modos (*natureza*) são **três**: 

### numeric (**número**): *1*
### character (**texto**): *"a"* ou *"2500"*
### logical (**lógico**): *TRUE* ou *FALSE*

---

class: inverse, middle, center

# Dúvidas?

---

# 3.6 Estrutura dos objetos

## Estruturas (*organização*): vector, factor, matrix, data frame e list

--

### Organização (**modos** e **dimensionalidade**) dos elementos dos objetos

--

background-image: url(https://devopedia.org/images/article/46/7262.1526126010.png)
background-size: 650px
background-position: 50% 90%

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.6 Estrutura dos objetos

---

background-image: url(http://www.simonqueenborough.info/R/basic/img/data/data-dimensions.png)
background-size: 700px
background-position: 50% 50%

# 3.3 Estrutura dos objetos

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.7 Estrutura dos objetos: vector

## **1. Vector**

---

# 3.7 Estrutura dos objetos: vector

## **1. Vector**: homogêneo (*um modo*) e unidimensional (*uma dimensão*)

--

### O **vetor** representa medidas de uma **variável quantitativa** (discretas ou contínuas) ou **descrição** (informações em texto)

--

### Ex.: medidas tomadas em campo ao longo de uma amostragem de 5 meses

--

1. Amostragens: {"amostra_01", "amostra_02", "amostra_03", "amostra_04", "amostra_05"}

--

2. Temperatura: {15, 18, 20, 22, 18}

--

3. Abertura do dossel: {0.37, 0.45, 0.65, 0.75, 0.40}

--

4. Abundância de uma espécie: {6, 3, 0, 0, 2}

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

--

### 1. Concatenar elementos

```r
# concatenar elementos
temp &lt;- c(15, 18, 20, 22, 18)
temp
```

```
## [1] 15 18 20 22 18
```
&lt;br&gt;
--

```r
amos &lt;- c("amostra_01", "amostra_02", "amostra_03", "amostra_04", "amostra_05")
amos
```

```
## [1] "amostra_01" "amostra_02" "amostra_03" "amostra_04" "amostra_05"
```

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

### 2. Sequência

```r
# sequencia unitaria (x1:x2)
se &lt;- 1:10
se
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```
&lt;br&gt;
--

```r
# sequencia com diferentes espacamentos 
se.e &lt;- seq(from = 0, to = 100, by = 10) 
se.e
```

```
##  [1]   0  10  20  30  40  50  60  70  80  90 100
```

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

### 3. Repetição

```r
# repeticao
# rep(x, times) # repete x tantas vezes
# rep(x, each) # retete x tantas vezes de cada

re.num.t &lt;- rep(x = c(1, 2), times = 5)
re.num.t
```

```
##  [1] 1 2 1 2 1 2 1 2 1 2
```
&lt;br&gt;
--

```r
re.num.e &lt;- rep(x = c(1, 2), each = 5)
re.num.e
```

```
##  [1] 1 1 1 1 1 2 2 2 2 2
```

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

### 3. Repetição

```r
# repeticao
# rep(x, times) # repete x tantas vezes
# rep(x, each) # retete x tantas vezes de cada

re.cha.n &lt;- rep(x = c("a", "b"), times = 5)
re.cha.n
```

```
##  [1] "a" "b" "a" "b" "a" "b" "a" "b" "a" "b"
```
&lt;br&gt;
--

```r
re.cha.c &lt;- rep(x = c("a", "b"), each = 5)
re.cha.c
```

```
##  [1] "a" "a" "a" "a" "a" "b" "b" "b" "b" "b"
```

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

### 3. Repetição

```r
# repeticao
# rep(x, times) # repete x tantas vezes
# rep(x, each) # retete x tantas vezes de cada

re.log.n &lt;- rep(x = c(TRUE, FALSE), times = 5)
re.log.n
```

```
##  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE
```
&lt;br&gt;
--

```r
re.log.c &lt;- rep(x = c(TRUE, FALSE), each = 5)
re.log.c
```

```
##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
```

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

### 4. "Colar" palavras com uma sequência numérica


```r
# palavra e sequencia numerica - sem separacao
am1 &lt;- paste("amostra", 1:6, sep = "0")
am1
```

```
## [1] "amostra01" "amostra02" "amostra03" "amostra04" "amostra05" "amostra06"
```
&lt;br&gt;
--

```r
# palavra e sequencia numerica - separacao por "_"
am2 &lt;- paste("amostra", 1:6, sep = "_0")
am2
```

```
## [1] "amostra_01" "amostra_02" "amostra_03" "amostra_04" "amostra_05"
## [6] "amostra_06"
```

---

class: inverse, middle, center

# Dúvidas?

---

class: inverse, middle, center

# Posso fazer uma pergunta!?

---

class: inverse, middle, center

# E se eu criar um vetor com elementos de *modos diferentes*?

---

# 3.7 Estrutura dos objetos: vector

## Vetor com elementos de **modos diferentes**:

--

&lt;br&gt;


```r
ve &lt;- c(1, "a", 3)
ve
```

```
## [1] "1" "a" "3"
```
--
&lt;br&gt;

```r
ve &lt;- c(1, "a", TRUE)
ve
```

```
## [1] "1"    "a"    "TRUE"
```

---

# Coerção

## Mudança do **modo** dos elementos para um **mesmo modo**

&lt;br&gt;&lt;br&gt;&lt;br&gt;

--

## Essa mudança segue essa ordem:

### `DOMINANTE` **character** &gt;&gt; **numeric** &gt;&gt; **logical** `RECESSIVO`

---

# Coerção

## **character** &gt;&gt; **numeric**


```r
ve &lt;- c("a", 1)
ve
```

```
## [1] "a" "1"
```
--

```r
class(ve)
```

```
## [1] "character"
```

```r
mode(ve)
```

```
## [1] "character"
```

---

# Coerção

## **numeric** &gt;&gt; **logical**


```r
ve &lt;- c(1, TRUE)
ve
```

```
## [1] 1 1
```
--

```r
class(ve)
```

```
## [1] "numeric"
```

```r
mode(ve)
```

```
## [1] "numeric"
```

---

# Coerção

## **character** &gt;&gt; **logical**


```r
ve &lt;- c("a", TRUE)
ve
```

```
## [1] "a"    "TRUE"
```
--

```r
class(ve)
```

```
## [1] "character"
```

```r
mode(ve)
```

```
## [1] "character"
```

---

# Coerção

## **character** &gt;&gt; **numeric** &gt;&gt; **logical**


```r
ve &lt;- c("a", 1, TRUE)
ve
```

```
## [1] "a"    "1"    "TRUE"
```
--

```r
class(ve)
```

```
## [1] "character"
```

```r
mode(ve)
```

```
## [1] "character"
```

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

--

### Ideia semelhante: mudar o **tipo da célula** numa planilha eletrônica

--

### Vetor **numeric**

```r
ve &lt;- c(0, 1, 2, 3, 4)
ve
```

```
## [1] 0 1 2 3 4
```
--

```r
mode(ve)
```

```
## [1] "numeric"
```

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

### Forçar a ser **character**, vindo de um **numeric**

```r
ve
```

```
## [1] 0 1 2 3 4
```
--

```r
ve.c &lt;- as.character(ve)
ve.c
```

```
## [1] "0" "1" "2" "3" "4"
```
--

```r
mode(ve.c)
```

```
## [1] "character"
```

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

### Forçar a ser **logical**, vindo de um **numeric**

```r
ve
```

```
## [1] 0 1 2 3 4
```
--

```r
ve.l &lt;- as.logical(ve)
ve.l
```

```
## [1] FALSE  TRUE  TRUE  TRUE  TRUE
```
--

```r
mode(ve.l)
```

```
## [1] "logical"
```

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

### Forçar a ser **numeric**, vindo de um **character**

```r
ve.c
```

```
## [1] "0" "1" "2" "3" "4"
```
--

```r
ve.n &lt;- as.numeric(ve.c)
ve.n
```

```
## [1] 0 1 2 3 4
```
--

```r
mode(ve.n)
```

```
## [1] "numeric"
```

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

### Forçar a ser **numeric**, vindo de um **logical**

```r
ve.l
```

```
## [1] FALSE  TRUE  TRUE  TRUE  TRUE
```
--

```r
ve.n &lt;- as.numeric(ve.l)
ve.n
```

```
## [1] 0 1 1 1 1
```
--

```r
mode(ve.n)
```

```
## [1] "numeric"
```

---

class: inverse, middle, center

# Dúvidas?

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.8 Estrutura dos objetos: factor

## **2. Factor**

---

# 3.8 Estrutura dos objetos: factor

## **2. Factor**: homogêneo (*um modo* - sempre *numeric*), unidimensional (*uma dimensão*) e possui ainda **levels** (níveis)

--

### O **factor** representa medidas de uma **variável qualitativa**, podendo ser **nominal** ou **ordinal**

--

### Ex.: medidas tomadas em campo ao longo de uma amostragem de 6 meses

--

1. Amostragens: {"amostra_01", "amostra_02", "amostra_03", "amostra_04", "amostra_05"}

--

2. Tipo de floresta: {fechada, fechada, aberta, aberta, aberta}

--

3. Abundância de uma espécie: {alta, media, baixa, baixa, media}

---

# 3.8 Estrutura dos objetos: factor

## **2. Factor nominal**: variáveis nominais


```r
fa.no &lt;- factor(x = c("fechada", "fechada", "aberta", "aberta", "aberta"),
                levels = c("aberta", "fechada"))
fa.no
```

```
## [1] fechada fechada aberta  aberta  aberta 
## Levels: aberta fechada
```
--

```r
levels(fa.no)
```

```
## [1] "aberta"  "fechada"
```
---

# 3.8 Estrutura dos objetos: factor

## **2. Factor ordinal**: variáveis ordinais

```r
fa.or &lt;- factor(x = c("alta", "media", "baixa", "baixa", "media"),
                levels = c("baixa", "media", "alta"), ordered = TRUE)
fa.or
```

```
## [1] alta  media baixa baixa media
## Levels: baixa &lt; media &lt; alta
```
--

```r
levels(fa.or)
```

```
## [1] "baixa" "media" "alta"
```

---

# 3.8 Estrutura dos objetos: factor

## **2. Factor** conversão

--

### Criar um vetor **character**

```r
ve.ch &lt;- c("alta", "media", "baixa", "baixa", "media")
ve.ch
```

```
## [1] "alta"  "media" "baixa" "baixa" "media"
```
--

```r
mode(ve.ch)
```

```
## [1] "character"
```
--

```r
class(ve.ch)
```

```
## [1] "character"
```

---

# 3.8 Estrutura dos objetos: factor

## **2. Factor**: conversão

--

### Forçar a ser **factor nominal**

```r
fa.no &lt;- as.factor(ve.ch)
fa.no
```

```
## [1] alta  media baixa baixa media
## Levels: alta baixa media
```
--

```r
levels(fa.no)
```

```
## [1] "alta"  "baixa" "media"
```
--

```r
class(fa.no)
```

```
## [1] "factor"
```

---

# 3.8 Estrutura dos objetos: factor

## **2. Factor**: conversão

### Forçar a ser **factor ordinal**

```r
fa.no &lt;- as.ordered(ve.ch)
fa.no
```

```
## [1] alta  media baixa baixa media
## Levels: alta &lt; baixa &lt; media
```
--

```r
levels(fa.no)
```

```
## [1] "alta"  "baixa" "media"
```
--

```r
class(fa.no)
```

```
## [1] "ordered" "factor"
```

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**

---

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**: homogêneo (*um modo*) e bidimensional (*duas dimensão*)

--

### A **matrix** representa os dados no formato de **tabela**, com **linhas** e **colunas**

--

### As **linhas** representam **unidades amostrais** (locais, transectos, parcelas) e as **coluncas** representam **variáveis quantitativas** (discretas ou contínuas) ou **descrições** (informações em texto)

---

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**: homogêneo (*um modo*) e bidimensional (*duas dimensão*)

### Ex.: espécies amostradas 5 locais

--

background-image: url(https://www.neonscience.org/sites/default/files/images/R/matrix.png)
background-size: 630px
background-position: 130% 150%

---

class: inverse, middle, center

# Esse formato lembra algo?

---

background-image: url(https://i.blogs.es/5415b1/excel-calc/1366_2000.png)
background-size: 700px
background-position: 50% 60%

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**: planilhas eletrônicas

---

class: inverse, center, middle
background-image: url(https://media.giphy.com/media/xT0xeJpnrWC4XWblEk/giphy.gif)
background-size: 700px
background-position: 50% 60%

---

# 3.9 Estrutura dos objetos: matrix

## Há **duas formas** de se construir uma **matrix** no R:

### 1 Dispondo elementos

`matrix`: dispõem um vetor em um certo número de linhas e colunas


```r
# matriz - funcao matrix
# vetor
ve &lt;- 1:12
```
--

```r
# matrix - preenchimento por linhas - horizontal
ma.row &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = TRUE)
ma.row
```

```
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9
## [4,]   10   11   12
```

---

# 3.9 Estrutura dos objetos: matrix

## Há **duas formas** de se construir uma **matrix** no R:

### 1 Dispondo elementos

`matrix`: dispõem um vetor em um certo número de linhas e colunas


```r
# matriz - funcao matrix
# vetor
ve &lt;- 1:12
```
--

```r
# matrix - preenchimento por colunas - vertical
ma.col &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = FALSE)
ma.col
```

```
##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
```

---

# 3.9 Estrutura dos objetos: matrix

## Há **duas formas** de se construir uma **matrix** no R:

###  2 Combinando vetores
`rbind`: combina vetores por linha, i.e., vetor embaixo do outro

`cbind`: combina vetores por coluna, i.e., vetor ao lado do outro


```r
# criar dois vetores
vec.1 &lt;- c(1, 2, 3)
vec.2 &lt;- c(4, 5, 6)
```
--

```r
# combinar por linhas - vertical - um embaixo do outro
ma.rbind &lt;- rbind(vec.1, vec.2)
ma.rbind
```

```
##       [,1] [,2] [,3]
## vec.1    1    2    3
## vec.2    4    5    6
```

---

# 3.9 Estrutura dos objetos: matrix

## Há **duas formas** de se construir uma **matrix** no R:

###  2 Combinando vetores
`rbind`: combina vetores por linha, i.e., vetor embaixo do outro

`cbind`: combina vetores por coluna, i.e., vetor ao lado do outro


```r
# criar dois vetores
vec.1 &lt;- c(1, 2, 3)
vec.2 &lt;- c(4, 5, 6)
```
--

```r
# combinar por colunas - horizontal - um ao lado do outro
ma.cbind &lt;- cbind(vec.1, vec.2)
ma.cbind
```

```
##      vec.1 vec.2
## [1,]     1     4
## [2,]     2     5
## [3,]     3     6
```

---

# 3.9 Estrutura dos objetos: matrix

## Coerção

```r
# criar dois vetores
vec.ch &lt;- c("sp1", "sp2", "sp3")
vec.nu &lt;- c(4, 5, 6)
```
--

```r
# combinar por colunas - horizontal - um ao lado do outro
ma.ch &lt;- cbind(vec.ch, vec.nu)
ma.ch
```

```
##      vec.ch vec.nu
## [1,] "sp1"  "4"   
## [2,] "sp2"  "5"   
## [3,] "sp3"  "6"
```

---

# 3.9 Estrutura dos objetos: matrix

## Coerção

```r
# criar dois vetores
vec.ch &lt;- c("sp1", "sp2", "sp3")
vec.lo &lt;- c(TRUE, TRUE, FALSE)
```
--

```r
# combinar por linhas - vertical - um embaixo do outro
ma.ch &lt;- rbind(vec.ch, vec.lo)
ma.ch
```

```
##        [,1]   [,2]   [,3]   
## vec.ch "sp1"  "sp2"  "sp3"  
## vec.lo "TRUE" "TRUE" "FALSE"
```

---

# 3.9 Estrutura dos objetos: matrix

## Coerção

```r
# criar dois vetores
vec.nu &lt;- c(1, 2, 3)
vec.lo &lt;- c(TRUE, TRUE, FALSE)
```
--

```r
# combinar por linhas - vertical - um embaixo do outro
ma.nu &lt;- rbind(vec.nu, vec.lo)
ma.nu
```

```
##        [,1] [,2] [,3]
## vec.nu    1    2    3
## vec.lo    1    1    0
```

---

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**: homogêneo (*um modo*), bidimensional (*duas dimensão*)

## Essa mudança também segue a ordem:

### `DOMINANTE` **character** &gt;&gt; **numeric** &gt;&gt; **logical** `RECESSIVO`

---

class: inverse, middle, center

# E a **conversão**?

---

# 3.9 Estrutura dos objetos: matrix

## Conversão

--

&lt;br&gt;&lt;br&gt;&lt;br&gt;


```r
as.character(ma.nu)
```

```
## [1] "1" "1" "2" "1" "3" "0"
```

---

class: inverse, middle, center

# Falhou miseravelmente....

---

# 3.9 Estrutura dos objetos: matrix

## As conversões

### `as.numeric`

### `as.character`

### `as.logical`

##  sempre geram um **vector**!

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.10 Estrutura dos objetos: array

## **4. Array**

---

# 3.10 Estrutura dos objetos: array

## **4. Array**: homogêneo (*um modo*) e multidimensional (*mais que duas dimensões*)

--

### O **array** representa combinação de **tabelas**, com **linhas**, **colunas** e **dimensões**

--

background-image: url(https://www.neonscience.org/sites/default/files/images/R/array.png)
background-size: 480px
background-position: 50% 100%

---

class: inverse, center, middle
background-image: url(https://media.giphy.com/media/11ahZZugJHrdLO/giphy.gif)
background-size: 700px
background-position: 50% 50%

---

# 3.10 Estrutura dos objetos: array

## Há **uma forma** de se construir um **array** no R:

### 1 Dispondo elementos

`array`: dispõem um vetor em um certo número de linhas, colunas e dimensões....


```r
# vetor
ve &lt;- 1:8
ve
```

```
## [1] 1 2 3 4 5 6 7 8
```

---

# 3.10 Estrutura dos objetos: array

## Há **uma forma** de se construir um **array** no R:

### 1 Dispondo elementos

`array`: dispõem um vetor em um certo número de linhas, colunas e dimensões....

```r
ar &lt;- array(data = ve, dim = c(2, 2, 4))
ar
```

```
## , , 1
## 
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## , , 2
## 
##      [,1] [,2]
## [1,]    5    7
## [2,]    6    8
## 
## , , 3
## 
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## , , 4
## 
##      [,1] [,2]
## [1,]    5    7
## [2,]    6    8
```

---

background-image: url(http://www.simonqueenborough.info/R/basic/img/data/data-array.png)
background-size: 700px
background-position: 50% 120%

# 3.10 Estrutura dos objetos

## Até o momento vimos **estruturas homogêneas**

---

background-image: url(http://www.simonqueenborough.info/R/basic/img/data/data-same.png)
background-size: 700px
background-position: 50% 120%

# 3.10 Estrutura dos objetos

## Agora veremos as **estruturas heterogêneos**

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.10 Estrutura dos objetos: data frame

## **5. Data frame**

---

# 3.10 Estrutura dos objetos: data frame

## **5. Data frame**: heterogêneo (*mais de um modo*) e bidimensional (*duas dimensões*)

--

### O **data frame** representa dados no formato de **tabela**, com **linhas** e **colunas**

--

### As **linhas** representam **unidades amostrais** (locais, transectos, parcelas) e as **colunas** representam **descrições** (informações em texto), **variáveis quantitativas** (discretas ou contínuas) e/ou **variáveis qualitativas** (nominais ou ordinais)

---

background-image: url(http://s3.amazonaws.com/libapps/accounts/17830/images/r_data_structures.png)
background-size: 800px
background-position: 50% 60%

# 3.10 Estrutura dos objetos: data frame

## **5. Data frame**: heterogêneo (*mais de um modo*) e bidimensional (*duas dimensões*)

---

class: inverse, middle, center

# Esse formato também lembra algo?

---

background-image: url(https://i.blogs.es/5415b1/excel-calc/1366_2000.png)
background-size: 700px
background-position: 50% 60%

# 3.10 Estrutura dos objetos: data frame

## **5. Data frame**: planilhas eletrônicas

---

class: inverse, middle, center

# Ótimo, porque é justamente esse o formato de entrada dos dados de planilhas eletrônicas!

---

class: inverse, center, middle
background-image: url(https://media.giphy.com/media/3o7TKSjRrfIPjeiVyM/giphy.gif)
background-size: 700px

---

# 3.10 Estrutura dos objetos: data frame

## Há **uma forma** de se construir um **data frame** no R:

### 1 Combinando vetores horizontalmente

`data.frame`: combina vetores horizontalmente, um ao lado do outro. Semelhante à função `cbind`


```r
# criar três vetores
vec.ch &lt;- c("sp1", "sp2", "sp3")
vec.nu &lt;- c(4, 5, 6)
vec.fa &lt;- factor(c("campo", "floresta", "floresta"))
```
--

```r
# data.frame - combinar por colunas - horizontal - um ao lado do outro
df &lt;- data.frame(vec.ch, vec.nu, vec.fa)
df
```

```
##   vec.ch vec.nu   vec.fa
## 1    sp1      4    campo
## 2    sp2      5 floresta
## 3    sp3      6 floresta
```

---

# 3.10 Estrutura dos objetos: data frame

## Há **uma forma** de se construir um **data frame** no R:

### 1 Combinando vetores horizontalmente

### Também podemos informar o nome das colunas

--

```r
# data.frame
df &lt;- data.frame(especies = vec.ch, 
                 abundancia = vec.nu, 
                 vegetacao = vec.fa)
df
```

```
##   especies abundancia vegetacao
## 1      sp1          4     campo
## 2      sp2          5  floresta
## 3      sp3          6  floresta
```

---

# 3.10 Estrutura dos objetos: data frame

## Coerção de **data frame** para **matrix**

```r
# coercao de data frame para matrix
ma &lt;- as.matrix(df)
ma
```

```
##      especies abundancia vegetacao 
## [1,] "sp1"    "4"        "campo"   
## [2,] "sp2"    "5"        "floresta"
## [3,] "sp3"    "6"        "floresta"
```

### Seguindo aquela hierarquia
### `DOMINANTE` **character** &gt;&gt; **numeric** &gt;&gt; **logical** `RECESSIVO`

---

# 3.10 Estrutura dos objetos: data frame

## Coerção de **matrix** para **data frame**

```r
# coercao de matrix para data frame
df &lt;- as.data.frame(ma)
df
```

```
##   especies abundancia vegetacao
## 1      sp1          4     campo
## 2      sp2          5  floresta
## 3      sp3          6  floresta
```
--

```r
str(df)
```

```
## 'data.frame':	3 obs. of  3 variables:
##  $ especies  : Factor w/ 3 levels "sp1","sp2","sp3": 1 2 3
##  $ abundancia: Factor w/ 3 levels "4","5","6": 1 2 3
##  $ vegetacao : Factor w/ 2 levels "campo","floresta": 1 2 2
```

---

# 3.10 Estrutura dos objetos: data frame

## Coerção de **matrix** para **data frame**

```r
# coercao de matrix para data frame
df &lt;- as.data.frame(ma, stringsAsFactors = FALSE)
df
```

```
##   especies abundancia vegetacao
## 1      sp1          4     campo
## 2      sp2          5  floresta
## 3      sp3          6  floresta
```
--

```r
str(df)
```

```
## 'data.frame':	3 obs. of  3 variables:
##  $ especies  : chr  "sp1" "sp2" "sp3"
##  $ abundancia: chr  "4" "5" "6"
##  $ vegetacao : chr  "campo" "floresta" "floresta"
```

---

# 3.10 Estrutura dos objetos: data frame

## **data frame** vs **cbind**

### Criação dos vetores

```r
## vetores
pa &lt;- paste("parcela", 1:10, sep = "_")
pa
```

```
##  [1] "parcela_1"  "parcela_2"  "parcela_3"  "parcela_4"  "parcela_5" 
##  [6] "parcela_6"  "parcela_7"  "parcela_8"  "parcela_9"  "parcela_10"
```
--

```r
pe &lt;- sample(0:1, 10, rep = TRUE)
pe
```

```
##  [1] 1 1 1 1 1 0 1 0 1 0
```
--

```r
tr &lt;- factor(rep(c("trat", "cont"), each = 5))
tr
```

```
##  [1] trat trat trat trat trat cont cont cont cont cont
## Levels: cont trat
```

---

# 3.10 Estrutura dos objetos: data frame

### Qual a diferença?


```r
# uniao de vetores
df &lt;- data.frame(pa, pe, tr)
df
```

```
##            pa pe   tr
## 1   parcela_1  1 trat
## 2   parcela_2  1 trat
## 3   parcela_3  1 trat
## 4   parcela_4  1 trat
## 5   parcela_5  1 trat
## 6   parcela_6  0 cont
## 7   parcela_7  1 cont
## 8   parcela_8  0 cont
## 9   parcela_9  1 cont
## 10 parcela_10  0 cont
```
--

```r
str(df)
```

---

# 3.10 Estrutura dos objetos: data frame

### Qual a diferença?


```r
# uniao de vetores
df.c &lt;- cbind(pa, pe, tr)
df.c
```

```
##       pa           pe  tr 
##  [1,] "parcela_1"  "1" "2"
##  [2,] "parcela_2"  "1" "2"
##  [3,] "parcela_3"  "1" "2"
##  [4,] "parcela_4"  "1" "2"
##  [5,] "parcela_5"  "1" "2"
##  [6,] "parcela_6"  "0" "1"
##  [7,] "parcela_7"  "1" "1"
##  [8,] "parcela_8"  "0" "1"
##  [9,] "parcela_9"  "1" "1"
## [10,] "parcela_10" "0" "1"
```
--

```r
str(df.c)
```

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.11 Estrutura dos objetos: list

## **6. List**

---

# 3.11 Estrutura dos objetos: list

## **6. List**: heterogêneo (*mais de um modo*) e unidimensional (*uma dimensão*)

--

### Tipo **especial de vetor** que aceita **objetos** como **elementos**

--

### Estrutura de dados utilizado para **agrupar objetos**

--

### É a **saída** de muitas funções que fazem **análises estatísticas**

--

background-image: url(https://raw.githubusercontent.com/mauriciovancine/curso-r/master/imagens/list.png)
background-size: 300px
background-position: 50% 95%

---

# 3.11 Estrutura dos objetos: list

## **6. List**: heterogêneo (*mais de um modo*) e unidimensional (*uma dimensão*)


```r
li &lt;- list(rep(1, 20), # vector
           factor(1, 1), # factor
           cbind(c(1, 2), c(1, 2))) # matrix
li
```

```
## [[1]]
##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## 
## [[2]]
## [1] 1
## Levels: 1
## 
## [[3]]
##      [,1] [,2]
## [1,]    1    1
## [2,]    2    2
```

---

class: inverse, middle, center

# Dúvidas?

---

class: inverse, middle, center

# Exercícios!

---

class: inverse, middle, center
background-image: url(https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif)

---

# Exercícios

## 1. Criem um novo script

&lt;br&gt;&lt;br&gt;

### Pasta
`00_scripts`

&lt;br&gt;

### Arquivo
`script_r_curso_r_aula03_estrutura_dados_exercicios_2019_01_d08.R`

---

# Exercícios

## 2. Criem um cabeçalho descritivo nesse script

--


```r
### exercicios aula 03 - atributos dos dados ###

# nome
# data
```

---

# Exercícios

## 3. Removam todos os objetos criados anteriormente

--


```r
# solucao
## memoria
rm(list = ls())
```

---

# Exercícios

## 4. Criem um vetor chamado "lo" para descrever 100 locais de amostragem. O vetor deve ser dessa forma:

`local_1, local_2, local_3, ...., local_100`

--


```r
# solucao
lo &lt;- paste("local", 1:100, sep = "_")
lo
```

```
##   [1] "local_1"   "local_2"   "local_3"   "local_4"   "local_5"  
##   [6] "local_6"   "local_7"   "local_8"   "local_9"   "local_10" 
##  [11] "local_11"  "local_12"  "local_13"  "local_14"  "local_15" 
##  [16] "local_16"  "local_17"  "local_18"  "local_19"  "local_20" 
##  [21] "local_21"  "local_22"  "local_23"  "local_24"  "local_25" 
##  [26] "local_26"  "local_27"  "local_28"  "local_29"  "local_30" 
##  [31] "local_31"  "local_32"  "local_33"  "local_34"  "local_35" 
##  [36] "local_36"  "local_37"  "local_38"  "local_39"  "local_40" 
##  [41] "local_41"  "local_42"  "local_43"  "local_44"  "local_45" 
##  [46] "local_46"  "local_47"  "local_48"  "local_49"  "local_50" 
##  [51] "local_51"  "local_52"  "local_53"  "local_54"  "local_55" 
##  [56] "local_56"  "local_57"  "local_58"  "local_59"  "local_60" 
##  [61] "local_61"  "local_62"  "local_63"  "local_64"  "local_65" 
##  [66] "local_66"  "local_67"  "local_68"  "local_69"  "local_70" 
##  [71] "local_71"  "local_72"  "local_73"  "local_74"  "local_75" 
##  [76] "local_76"  "local_77"  "local_78"  "local_79"  "local_80" 
##  [81] "local_81"  "local_82"  "local_83"  "local_84"  "local_85" 
##  [86] "local_86"  "local_87"  "local_88"  "local_89"  "local_90" 
##  [91] "local_91"  "local_92"  "local_93"  "local_94"  "local_95" 
##  [96] "local_96"  "local_97"  "local_98"  "local_99"  "local_100"
```

---

# Exercícios

## 4. Criem um vetor chamado "lo" para descrever 100 locais de amostragem. O vetor deve ser dessa forma:

`local_001, local_002, local_003, ...., local_100`

--


```r
# solucao
lo.u &lt;- paste("local_00", 1:9, sep = "")
lo.u

lo.d &lt;- paste("local_0", 10:99, sep = "")
lo.d

lo &lt;- c(lo.u, lo.d, "local_100")
lo
```

---

# Exercícios

## 4. Criem um vetor chamado "lo" para descrever 100 locais de amostragem. O vetor deve ser dessa forma:

`local_001, local_002, local_003, ...., local_100`

--


```r
# solucao 2
lo.u &lt;- paste("local", 1:9, sep = "_00")
lo.u

lo.d &lt;- paste("local", 10:99, sep = "_0")
lo.d

lo &lt;- c(lo.u, lo.d, "local_100")
lo
```

---

# Exercícios

## 6. Criem um fator chamado "tr", com dois níveis ("cont" e "trat") para descrever 100 locais de amostragem, 50 de cada tratamento. O fator deve ser dessa forma:

`cont, cont, cont, ...., cont, trat, trat, trat, ...., trat`

--


```r
# solucao
re &lt;- rep(c("cont", "trat"), each = 50)
re

tr &lt;- factor(re, c("cont", "trat"))
tr
```

---

# Exercícios

## 6. Criem um fator chamado "tr", com dois níveis ("cont" e "trat") para descrever 100 locais de amostragem, 50 de cada tratamento. O fator deve ser dessa forma:

`cont, cont, cont, ...., cont, trat, trat, ...., trat`

--


```r
# solucao
tr &lt;- factor(rep(c("cont", "trat"), each = 50),
	        c("cont", "trat"))
tr
```

---

# Exercícios

## 7. Criem uma matriz chamada "ma", da disposição de um vetor composto por 100 valores aleatórios entre 0 e 10. A matriz deve conter 10 linhas e ser preenchida por colunas

--


```r
# solucao
ve &lt;- sample(0:10, 100, rep = TRUE)
ve
```
--

```r
ma &lt;- matrix(ve, 10, 10, byrow = FALSE)
ma
```

---

# Exercícios

## 8. Criem um data frame com dados fictícios de uma amostragem de plantas em 10 parcelas, contendo as seguintes colunas:

`1. nome: nome das parcelas (parcela 1 a 10)`

`2. sp1: abundância aleatória (valores entre 0 a 10) da sp1`

`3. sp2: abundância aleatória (valores entre 0 a 10) da sp2`

`4. sp3: abundância aleatória (valores entre 0 a 10) da sp3`

`5. temp: distribuição normal da temperatura (média = 20 e desvio padrão = 3)`

`6. prec: distribuição normal da precipitação (média = 1500 e desvio padrão = 200)`

`7. ins: distribuição normal da incidência solar (média = 50 e desvio padrão = 15)`

`8. inv: presençaa aleatória de uma planta invasora`

---

# Exercícios

## 8. Criem um data frame com dados fictícios de uma amostragem de plantas em 10 parcelas, contendo as seguintes colunas:


```r
# solucao
pa &lt;- c(paste("parcela", 1:9, sep = "_0"), "parcela_10")
pa
```

---

# Exercícios

## 8. Criem um data frame com dados fictícios de uma amostragem de plantas em 10 parcelas, contendo as seguintes colunas:


```r
# solucao
sp1 &lt;- sample(1:10, 10, rep = TRUE)
sp1

sp2 &lt;- sample(1:10, 10, rep = TRUE)
sp2

sp3 &lt;- sample(1:10, 10, rep = TRUE)
sp3
```

---

# Exercícios

## 8. Criem um data frame com dados fictícios de uma amostragem de plantas em 10 parcelas, contendo as seguintes colunas:


```r
# solucao
te &lt;- rnorm(10, 20, 3)
te

pr &lt;- rnorm(10, 1000, 200)
pr

so &lt;- rnorm(10, 50, 15)
so

iv &lt;- sample(0:1, 10, rep = TRUE)
iv
```

---

# Exercícios

## 8. Criem um data frame com dados fictícios de uma amostragem de plantas em 10 parcelas, contendo as seguintes colunas:


```r
# solucao
df &lt;- data.frame(pa, sp1, sp2, sp3, sp4, sp5, te, pr, so, iv)
df
```

---

# Exercícios

## 9. Criem uma lista chamada "li" contendo todos os objetos criados nos exercícios

--


```r
ls()
```
--

```r
li &lt;- list(df, iv, lo, lo.d, lo.u, pa, pr, so, sp1, sp2, sp3, sp4, sp5, te)
li
```

class: inverse, middle, center

# Dúvidas?

---

class: clear, middle

## Maurício H. Vancine

&lt;br&gt;

Contatos:

|                                                                                                            |                                   |
| :--------------------------------------------------------------------------------------------------------- | :-------------------------------- |
| &lt;a href="mailto:mauricio.vancine@gmail.com"&gt;.RUred[&lt;i class="fa fa-paper-plane fa-fw"&gt;&lt;/i&gt;]               | mauricio.vancine@gmail.com       |
| &lt;a href="mauriciovancine.github.io"&gt;.RUred[&lt;i class="fa fa-link fa-fw"&gt;&lt;/i&gt;] | mauriciovancine.github.io |
| &lt;a href="http://twitter.com/mauriciovancine"&gt;.RUred[&lt;i class="fa fa-twitter fa-fw"&gt;&lt;/i&gt;]                          | @mauriciovancine                         |
| &lt;a href="http://gitlab.com/mauriciovancine"&gt;.RUred[&lt;i class="fa fa-gitlab fa-fw"&gt;&lt;/i&gt;]                          | @mauriciovancine                       |
| &lt;a href="http://github.com/mauriciovancine"&gt;.RUred[&lt;i class="fa fa-github fa-fw"&gt;&lt;/i&gt;]                          | @mauriciovancine                       |

Slides criados via pacote [xaringan](https://github.com/yihui/xaringan) e tema [Metropolis](https://github.com/pat-s/xaringan-metropolis).
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
